generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("PRISMA_MIGRATION_SHADOW_DATABASE_URL")
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  role         Role     @default(USER)
  isVerified   Boolean  @default(false)
  failedLogins Int      @default(0)
  lockedUntil  DateTime?
  verificationToken   String? @unique
  verificationExpires DateTime?
  resetToken          String? @unique
  resetTokenExpires   DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  notes    Note[]
  progress Progress[]
  documents Document[]
  embeddings Embedding[]
  refreshTokens RefreshToken[]
}

enum Role {
  USER
  ADMIN
}

model RefreshToken {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Note {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  document  String
  page      Int
  content   String
  createdAt DateTime @default(now())
}

model Progress {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  document  String
  pagesRead Int      @default(0)
  minutes   Int      @default(0)
  date      DateTime @default(now())
}

model Document {
  id           String   @id @default(cuid())
  user         User     @relation(fields: [userId], references: [id])
  userId       String
  filename     String
  originalName String
  contentHash  String   @unique // SHA-256 hash of content to prevent duplicates
  fileSize     Int
  mimeType     String?
  status       DocumentStatus @default(PENDING)
  isSystemDocument Boolean @default(false)  // NEW FIELD ADDED
  
  // Processing metadata
  totalChunks     Int?     // Expected number of chunks
  processedChunks Int      @default(0)
  processingError String?
  startedAt       DateTime?
  completedAt     DateTime?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  embeddings   Embedding[]
  
  @@index([userId])
  @@index([contentHash])
  @@index([status])
}

enum DocumentStatus {
  PENDING     // Uploaded, waiting to process
  PROCESSING  // Currently being processed
  COMPLETED   // Successfully processed
  FAILED      // Processing failed
  CANCELLED   // Processing was cancelled
}

model Embedding {
  id         String   @id @default(cuid())
  user       User?    @relation(fields: [userId], references: [id])
  userId     String?
  document   Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId String?
  source     String   // Keep for backward compatibility
  chunk      String
  embedding  Json
  embedding_vec Unsupported("vector(768)")? // pgvector column for similarity search
  
  // Smart chunking metadata
  documentType String? // DocumentType enum value
  chunkIndex   Int?    // Position of this chunk in the document
  totalChunks  Int?    // Total number of chunks in the document
  section      String? // Section or heading this chunk belongs to
  startLine    Int?    // Starting line number in original document
  endLine      Int?    // Ending line number in original document
  chunkingConfig Json? // Configuration used for chunking
  
  // Adaptive chunking metadata
  sectionLevel Int?    // Heading level (1=chapter, 2=section, 3=subsection)
  pageStart    Int?    // Starting page number
  pageEnd      Int?    // Ending page number
  hasTable     Boolean @default(false) // Contains table data
  hasImage     Boolean @default(false) // Contains image references
  wordCount    Int?    // Number of words in this chunk
  
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([documentId])
  @@index([documentType])
  @@index([source, chunkIndex])
}

model RetrievalLog {
  id         String   @id @default(cuid())
  query      String
  results    Json
  metrics    Json?
  createdAt  DateTime @default(now())
}